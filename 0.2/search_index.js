var documenterSearchIndex = {"docs":
[{"location":"man/ipog/#In-parameter-order-General","page":"IPOG","title":"In-parameter-order General","text":"","category":"section"},{"location":"man/ipog/#Overview","page":"IPOG","title":"Overview","text":"","category":"section"},{"location":"man/ipog/","page":"IPOG","title":"IPOG","text":"There is an in-parameter-order general (IPOG) algorithm that is published, and I've extended it to be more user-friendly. I'll describe both here.","category":"page"},{"location":"man/ipog/#The-covering-problem","page":"IPOG","title":"The covering problem","text":"","category":"section"},{"location":"man/ipog/","page":"IPOG","title":"IPOG","text":"A combinatorial covering set is a way to select combinations of values for testing. We assume that there are param_cnt items to select. These could be parameter values to send to a function. They could be configuration values for a large simulation. They could be combinations of hardware to test together. We can represent a selected test case as an array of integers, [2, 4, 3, 2], which represents the second selection of the first item, the first selection of the second item, and so on. A test set is a list of test cases.","category":"page"},{"location":"man/ipog/","page":"IPOG","title":"IPOG","text":"We say that a test set has n-way covering when we can choose any n parameters and choose any possible combination of values of those parameters, and find them in some test case of the test set. We can think of the n-way combinations as their own data structure, a covering set, where we might represent it as an array that uses 0 to indicate paramters that aren't in the cover.","category":"page"},{"location":"man/ipog/","page":"IPOG","title":"IPOG","text":"[[1, 1, 0, 0],\n [2, 1, 0, 0],\n [1, 2, 0, 0],\n [0, 1, 1, 0]\n ...\n]","category":"page"},{"location":"man/ipog/","page":"IPOG","title":"IPOG","text":"A test set covers these tuples if every set of non-zero values in the covering set can be found in some test case of the test set.","category":"page"},{"location":"man/ipog/#IPOG","page":"IPOG","title":"IPOG","text":"","category":"section"},{"location":"man/ipog/","page":"IPOG","title":"IPOG","text":"Previous algorithms constructed a single, complete set of parameter values, called a test case, one at a time. This algorithm starts with a few parameters, finds a covering set for them, and then uses this as the basis to add a parameter at a time.","category":"page"},{"location":"man/ipog/","page":"IPOG","title":"IPOG","text":"There are a few sources for this work, which I annotate here.","category":"page"},{"location":"man/ipog/","page":"IPOG","title":"IPOG","text":"Lei, Yu, Raghu Kacker, D. Richard Kuhn, Vadim Okun, and James Lawrence. 2008. “IPOG/IPOG-D: Efficient Test Generation for Multi-Way Combinatorial Testing.” Software Testing, Verification & Reliability 18 (3): 125–48. - This is the most direct description.\nForbes, Michael, Jim Lawrence, Yu Lei, Raghu N. Kacker, and D. Richard Kuhn. 2008. “Refining the In-Parameter-Order Strategy for Constructing Covering Arrays.” Journal of Research of the National Institute of Standards and Technology 113 (5): 287–97. - This updates the algorithm to be more efficient and includes details not explained elsewhere.\nTai, Kuo-Chung, and Yu Lei. 2002. “A Test Generation Strategy for Pairwise Testing.” IEEE Transactions on Software Engineering 28 (1). - The original paper is interesting because it thinks more theoretically about the problem.\nKuhn, D. Richard, Raghu N. Kacker, and Yu Lei. 2013. Introduction to Combinatorial Testing. CRC Press. This book includes an algorithm description, but it may mix up one of the loops.","category":"page"},{"location":"man/ipog/","page":"IPOG","title":"IPOG","text":"A sketch of the algorithm.","category":"page"},{"location":"man/ipog/","page":"IPOG","title":"IPOG","text":"Given:\narity - which is the number of values for each parameter.\nn_way - which is the coverage level (2, 3,...)\nSort the parameters by non-increasing arity. Record this ordering so you can reorder it at the end.\nConstruct an n_way full-factorial combination of the first n_way parameters. This is a correct covering for n_way parameters.\nAdd an n_way+1 value to each test case of those already found. This is called \"widening,\" and we will describe it in more detail below.\nFor all coverage tuples that include the n_way+1 parameter, loop over the tuples and, first, search for a place to put them in the existing test cases. If there is no spot to put them, then add them as a last test case. They will have missing values, which you mark as missing.\nRepeat for each parameter until done.\nFill missing values and reorder parameters before returning test cases.","category":"page"},{"location":"man/ipog/","page":"IPOG","title":"IPOG","text":"The widening step first constructs a list of all covers that include the last parameter. Then it loops over the existing test cases, which have missing values for this new parameter, and it looks for any place it can insert values in order to increase coverage. If an insertion won't increase coverage, it is left blank because a later parameter might use this spot. We denote blanks with 0.","category":"page"},{"location":"man/ipog/","page":"IPOG","title":"IPOG","text":"The lengthening step, to add test cases, doesn't loop over test cases to add. It loops over the coverage. It's much more efficient this way. For each cover, it looks to see if there was a place to insert that cover in existing test cases, and then it adds it to the end, using 0 to denote missing values.","category":"page"},{"location":"man/ipog/","page":"IPOG","title":"IPOG","text":"The papers go into ways to make this all faster. I'd like to point out a detail I haven't seen discussed, which is that there are several ways to match cases to covers.","category":"page"},{"location":"man/ipog/","page":"IPOG","title":"IPOG","text":"Let's assume that a test case is represented as a vector [1, 0, 2, 0, 4], where 0 means it has a missing value, not yet decided. Vectors aren't likely the best data structure, but we can use it to discuss the algorithm anyway. Then a cover might be [0, 1, 0, 0, 0, 4]. We need to decide, at different steps, whether to insert a cover into a test case. If we look at any single parameter, there are five different comparisons possible.","category":"page"},{"location":"man/ipog/","page":"IPOG","title":"IPOG","text":"ignores(a, b) = a == 0 && b == 0\nskips(a, b) = a != 0 && b == 0\nmisses(a, b) = a == 0 && b != 0\nmatches(a, b) = a != 0 && b != 0 && a == b\nmismatch(a, b) = a != 0 && b != 0 && a != b","category":"page"},{"location":"man/ipog/","page":"IPOG","title":"IPOG","text":"We could call a cover a match when there are no mismatches. This includes cases where the cover's nonzeros and the case's nonzeros don't overlap. We could call a cover a match when at least one nonzero matches. There are a few versions of this.","category":"page"},{"location":"man/ipog/","page":"IPOG","title":"IPOG","text":"According to projective geometry principles, I have no clue about projective geometry principles. I made a bunch of matching functions and ran the algorithm with different versions until it suddenly made much smaller test sets. Those test sets agree with ones that are published.","category":"page"},{"location":"man/ipog/#Expanding-IPOG","page":"IPOG","title":"Expanding IPOG","text":"","category":"section"},{"location":"man/ipog/","page":"IPOG","title":"IPOG","text":"We almost never want a set of test cases from the IPO algorithm. We want test cases that we can use for a particular function or to generate test data for a program, and those have limitations.","category":"page"},{"location":"man/ipog/","page":"IPOG","title":"IPOG","text":"The test generator has to exclude parameter combinations. Some combinations of parameter values are uninteresting. It could be that we don't think there is risk associated with those values or that we aren't testing exception cases at the moment.\nThe test generator has to include certain test cases. If I know a few test cases are interesting, I want to start with these, and they should count against the overall coverage. We're assuming the thing we're testing is relatively slow.\nThe test generator has to let me increase coverage on certain parameters. If I'm generating a configuration file with these test cases, it could have forty parameters, of which I think ten are the most risky. I don't want 4-way coverage on the whole thing because that's a huge test set, but I do want 4-way coverage of those ten parameter values.","category":"page"},{"location":"man/ipog/","page":"IPOG","title":"IPOG","text":"I haven't found papers on how to add these features to IPOG, so I added some algorithms.","category":"page"},{"location":"man/ipog/","page":"IPOG","title":"IPOG","text":"For excluding parameter combinations, you pass in a function that tests whethere the given arguments are allowed. The algorithm internally runs this function on every covering tuple and every test case to see whether the given value should be chosen. That's kind of it.","category":"page"},{"location":"man/ipog/","page":"IPOG","title":"IPOG","text":"For adding seed cases, we have to add them, in this algorithm, parameter by parameter. The algorithm makes the seeds the first test cases and fills them in as it goes. For the first step, to create all n-way combinations of parameters, the algorithm only adds combinations that don't already exist in the test cases.","category":"page"},{"location":"man/ipog/","page":"IPOG","title":"IPOG","text":"It's tricky with IPOG to increase coverage only for certain sets of parameters. I haven't tested this against different methods, but I made a method that runs. I run IPOG multiple times, once for each coverage set. Every time I run IPOG, I treat the existing test cases as seeds for the next run. Those seeds might have lots of zero values, but they get filled in as it goes.","category":"page"},{"location":"man/code_of_conduct/#Contributor-Covenant-Code-of-Conduct","page":"Contributor Covenant Code of Conduct","title":"Contributor Covenant Code of Conduct","text":"","category":"section"},{"location":"man/code_of_conduct/#Our-Pledge","page":"Contributor Covenant Code of Conduct","title":"Our Pledge","text":"","category":"section"},{"location":"man/code_of_conduct/","page":"Contributor Covenant Code of Conduct","title":"Contributor Covenant Code of Conduct","text":"We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","category":"page"},{"location":"man/code_of_conduct/","page":"Contributor Covenant Code of Conduct","title":"Contributor Covenant Code of Conduct","text":"We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.","category":"page"},{"location":"man/code_of_conduct/#Our-Standards","page":"Contributor Covenant Code of Conduct","title":"Our Standards","text":"","category":"section"},{"location":"man/code_of_conduct/","page":"Contributor Covenant Code of Conduct","title":"Contributor Covenant Code of Conduct","text":"Examples of behavior that contributes to a positive environment for our community include:","category":"page"},{"location":"man/code_of_conduct/","page":"Contributor Covenant Code of Conduct","title":"Contributor Covenant Code of Conduct","text":"Demonstrating empathy and kindness toward other people\nBeing respectful of differing opinions, viewpoints, and experiences\nGiving and gracefully accepting constructive feedback\nAccepting responsibility and apologizing to those affected by our mistakes, and learning from the experience\nFocusing on what is best not just for us as individuals, but for the overall community","category":"page"},{"location":"man/code_of_conduct/","page":"Contributor Covenant Code of Conduct","title":"Contributor Covenant Code of Conduct","text":"Examples of unacceptable behavior include:","category":"page"},{"location":"man/code_of_conduct/","page":"Contributor Covenant Code of Conduct","title":"Contributor Covenant Code of Conduct","text":"The use of sexualized language or imagery, and sexual attention or advances of any kind\nTrolling, insulting or derogatory comments, and personal or political attacks\nPublic or private harassment\nPublishing others' private information, such as a physical or email address, without their explicit permission\nOther conduct which could reasonably be considered inappropriate in a professional setting","category":"page"},{"location":"man/code_of_conduct/#Enforcement-Responsibilities","page":"Contributor Covenant Code of Conduct","title":"Enforcement Responsibilities","text":"","category":"section"},{"location":"man/code_of_conduct/","page":"Contributor Covenant Code of Conduct","title":"Contributor Covenant Code of Conduct","text":"Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.","category":"page"},{"location":"man/code_of_conduct/","page":"Contributor Covenant Code of Conduct","title":"Contributor Covenant Code of Conduct","text":"Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.","category":"page"},{"location":"man/code_of_conduct/#Scope","page":"Contributor Covenant Code of Conduct","title":"Scope","text":"","category":"section"},{"location":"man/code_of_conduct/","page":"Contributor Covenant Code of Conduct","title":"Contributor Covenant Code of Conduct","text":"This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.","category":"page"},{"location":"man/code_of_conduct/#Enforcement","page":"Contributor Covenant Code of Conduct","title":"Enforcement","text":"","category":"section"},{"location":"man/code_of_conduct/","page":"Contributor Covenant Code of Conduct","title":"Contributor Covenant Code of Conduct","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at [INSERT CONTACT METHOD]. All complaints will be reviewed and investigated promptly and fairly.","category":"page"},{"location":"man/code_of_conduct/","page":"Contributor Covenant Code of Conduct","title":"Contributor Covenant Code of Conduct","text":"All community leaders are obligated to respect the privacy and security of the reporter of any incident.","category":"page"},{"location":"man/code_of_conduct/#Enforcement-Guidelines","page":"Contributor Covenant Code of Conduct","title":"Enforcement Guidelines","text":"","category":"section"},{"location":"man/code_of_conduct/","page":"Contributor Covenant Code of Conduct","title":"Contributor Covenant Code of Conduct","text":"Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:","category":"page"},{"location":"man/code_of_conduct/#.-Correction","page":"Contributor Covenant Code of Conduct","title":"1. Correction","text":"","category":"section"},{"location":"man/code_of_conduct/","page":"Contributor Covenant Code of Conduct","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.","category":"page"},{"location":"man/code_of_conduct/","page":"Contributor Covenant Code of Conduct","title":"Contributor Covenant Code of Conduct","text":"Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.","category":"page"},{"location":"man/code_of_conduct/#.-Warning","page":"Contributor Covenant Code of Conduct","title":"2. Warning","text":"","category":"section"},{"location":"man/code_of_conduct/","page":"Contributor Covenant Code of Conduct","title":"Contributor Covenant Code of Conduct","text":"Community Impact: A violation through a single incident or series of actions.","category":"page"},{"location":"man/code_of_conduct/","page":"Contributor Covenant Code of Conduct","title":"Contributor Covenant Code of Conduct","text":"Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.","category":"page"},{"location":"man/code_of_conduct/#.-Temporary-Ban","page":"Contributor Covenant Code of Conduct","title":"3. Temporary Ban","text":"","category":"section"},{"location":"man/code_of_conduct/","page":"Contributor Covenant Code of Conduct","title":"Contributor Covenant Code of Conduct","text":"Community Impact: A serious violation of community standards, including sustained inappropriate behavior.","category":"page"},{"location":"man/code_of_conduct/","page":"Contributor Covenant Code of Conduct","title":"Contributor Covenant Code of Conduct","text":"Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.","category":"page"},{"location":"man/code_of_conduct/#.-Permanent-Ban","page":"Contributor Covenant Code of Conduct","title":"4. Permanent Ban","text":"","category":"section"},{"location":"man/code_of_conduct/","page":"Contributor Covenant Code of Conduct","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.","category":"page"},{"location":"man/code_of_conduct/","page":"Contributor Covenant Code of Conduct","title":"Contributor Covenant Code of Conduct","text":"Consequence: A permanent ban from any sort of public interaction within the community.","category":"page"},{"location":"man/code_of_conduct/#Attribution","page":"Contributor Covenant Code of Conduct","title":"Attribution","text":"","category":"section"},{"location":"man/code_of_conduct/","page":"Contributor Covenant Code of Conduct","title":"Contributor Covenant Code of Conduct","text":"This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 2.0, available at [https://www.contributor-covenant.org/version/2/0/codeofconduct.html][v2.0].","category":"page"},{"location":"man/code_of_conduct/","page":"Contributor Covenant Code of Conduct","title":"Contributor Covenant Code of Conduct","text":"Community Impact Guidelines were inspired by  [Mozilla's code of conduct enforcement ladder][Mozilla CoC].","category":"page"},{"location":"man/code_of_conduct/","page":"Contributor Covenant Code of Conduct","title":"Contributor Covenant Code of Conduct","text":"For answers to common questions about this code of conduct, see the FAQ at [https://www.contributor-covenant.org/faq][FAQ]. Translations are available  at [https://www.contributor-covenant.org/translations][translations].","category":"page"},{"location":"man/code_of_conduct/","page":"Contributor Covenant Code of Conduct","title":"Contributor Covenant Code of Conduct","text":"[homepage]: https://www.contributor-covenant.org [v2.0]: https://www.contributor-covenant.org/version/2/0/codeofconduct.html [Mozilla CoC]: https://github.com/mozilla/diversity [FAQ]: https://www.contributor-covenant.org/faq [translations]: https://www.contributor-covenant.org/translations","category":"page"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/#Examples-of-contributions","page":"Contributing","title":"Examples of contributions","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Adding an algorithm for test case generation.\nTelling me which package already has an algorithm to use.\nImproving the documentation or testing builds.\nSuggesting a better API.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"The Github site has an Issues page, and my email is listed.","category":"page"},{"location":"contributing/#Branch-process","page":"Contributing","title":"Branch process","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"The trunk is called main. I use PRs from branches or other repos to main. If this project needs more than that, let's discuss it.","category":"page"},{"location":"contributing/#Conduct","page":"Contributing","title":"Conduct","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Let's follow the Contributor Covenant Code of Conduct.","category":"page"},{"location":"man/guide/#Guide","page":"Guide","title":"Guide","text":"","category":"section"},{"location":"man/guide/#Kinds-of-test-generation","page":"Guide","title":"Kinds of test generation","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Combinatorial coverage - Makes the shortest test sets to cover all options.\nall_values: Every value is used at least once.\nall_pairs: Every pair of values is used at least once.\nall_triples: Every triple of values is used at least once.\nall_tuples: Generate test sets with arbitrary coverage level.\nExcursions from a single parameter set\nvalues_excursion: Tries each parameter, one at a time.\npairs_excursion: Tries pairs of parameters, two at a time.\ntriples_excursion: Tries three parameters away from the original set.\nall_tuples: This function works for general excursions, too.\nFull factorial - Every combinations of parameters.\nfull_factorial: Generates all combinations of parameters, filtering those that aren't permitted.","category":"page"},{"location":"man/guide/#Same-interface-for-all-test-generators","page":"Guide","title":"Same interface for all test generators","text":"","category":"section"},{"location":"man/guide/#Increase-coverage-for-subsets-of-parameters","page":"Guide","title":"Increase coverage for subsets of parameters","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Sometimes there are a few parameters that are more important to test fully. In that case, choose a base-level coverage for the whole test set, such as the 2-way coverage of all-pairs. Then pass a separate argument to request that the subset of parameters have greater coverage.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"For instance, this requrests that the first, third, and fourth parameters have 3-way coverage, meaning full-factorial, while the second parameter has only 2-way coverage. This is more meaningful when there are lots of parameters.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"using UnitTestDesign  # hide\ntest_set = all_pairs(\n    [1, 2, 3], [\"low\", \"mid\" ,\"high\"], [1.0, 3.7, 4.9], [:greedy, :relax, :optim];\n    wayness = Dict(3 => [[1, 3, 4]])\n    )","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The wayness argument is a dictionary, where the dictionary keys are the higher coverage levels, so \"3\" means all triples. The dictionary values are an array of arrays of parameter indices which, together, should be covered at the given level. This means that, were you to have 40 parameters, you could request that parameters [3:6] and parameters [25:30] be covered with triples.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"array_of_forty_parameters = fill(1:4, 40)\ntest_set = all_pairs(\n    array_of_forty_parameters...;\n    wayness = Dict(3 => [[3:6], [25:30]])\n    )","category":"page"},{"location":"man/guide/#Exclude-forbidden-combinations-of-parameters","page":"Guide","title":"Exclude forbidden combinations of parameters","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Keep the test engine from making tests that aren't allowed for your function. Pass it a filter function, one that returns true whenever a parameter combinations is forbidden.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"using UnitTestDesign  # hide\ndisallow(n, level, value, kind) = level == \"high\" && kind == :optim\ntest_set = all_pairs(\n    [1, 2, 3], [\"low\", \"mid\" ,\"high\"], [1.0, 3.7, 4.9], [:greedy, :relax, :optim];\n    disallow = disallow\n    )","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"There are two problems with excluding values.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The disallow function needs to handle possible nothing arguments. The generator will call this function on partially-constructed argument lists, and it will pass nothing for those arguments that have not yet been chosen.\nThe generator may fail to find a solution if there is a disallow list. Both the IPOG and GND generators can get stuck when there are rules that forbid combinations. It depends on the combinations and some luck. When it does fail, you will see the code try to access a vector at location 0.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"There are papers that solve these problems by pairing tuple generation with logic solvers. That sounds great. It isn't implemented here.","category":"page"},{"location":"man/guide/#Seed-test-cases","page":"Guide","title":"Seed test cases","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"If there are particular tests that must be run, these already include some of the tuples that should be covered. You can pass the must-run test cases, and they will be included among the test cases.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"using UnitTestDesign  # hide\nmust_test = [[1, \"mid\", 3.7, :relax], [1, \"mid\", 4.9, :relax]]\ntest_cases = all_pairs(\n    [1, 2, 3], [\"low\", \"mid\" ,\"high\"], [1.0, 3.7, 4.9], [:greedy, :relax, :optim];\n    seeds = must_test\n    )","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The must-run cases are a list of arrays of arguments.","category":"page"},{"location":"man/methods/#Testing-Methods","page":"Testing Methods","title":"Testing Methods","text":"","category":"section"},{"location":"man/methods/#Partition-testing","page":"Testing Methods","title":"Partition testing","text":"","category":"section"},{"location":"man/methods/","page":"Testing Methods","title":"Testing Methods","text":"We've pretended, so far, that every function takes parameters that are selected from discrete, finite choices. Functions arguments can be floating-point values, integers from infinite sets, vectors of values, or trees of trees of values. Partition testing whittles down the nearly-infinite possible values into subsets which are likely to find the same faults in the function-under-test.","category":"page"},{"location":"man/methods/","page":"Testing Methods","title":"Testing Methods","text":"If a function integrates a value from a to b, then we could partition the possible a and b test values into those that are both negative, both positive, one negative and one positive. We could make a separate case for when they are very nearly equal or equal. That would make five partitions for these two variables. For each of those five partitions, we guess that it would be enough to choose some example value for testing.","category":"page"},{"location":"man/methods/","page":"Testing Methods","title":"Testing Methods","text":"test_set = all_pairs(\n    [:neg, :pos, :split, :near, :far], [0.1, 0.01, 0.001], [:RungeKutta, :Midpoint]\n    )\nab = Dict(:neg => (-3, -2), :pos => (2, 3), :split => (-2, 3),\n    :near => (4.999, 5), :far => (0, 1e7)\n)\nfor test_case in test_set\n    a, b = ab[test_case[1]]\n    result = custom_integrate(a, b, test_case[2:end]...)\n    @test result == compare_with_symbolic_integration(a, b)\nend","category":"page"},{"location":"man/methods/#Random-testing","page":"Testing Methods","title":"Random testing","text":"","category":"section"},{"location":"man/methods/","page":"Testing Methods","title":"Testing Methods","text":"Random testing side-steps the work, and fallibility, of partition testing by choosing input values randomly from their domain. If a can be any number between 0 and infinity, then let a random number generator pick it.","category":"page"},{"location":"man/methods/","page":"Testing Methods","title":"Testing Methods","text":"Random testing isn't blind to understanding what can go wrong in a function. It's no reason to forget to test edge cases. There is a procedure for constructing random tests that are biased towards finding edge cases.","category":"page"},{"location":"man/methods/","page":"Testing Methods","title":"Testing Methods","text":"Identify the whole domain of each parameter and the set of parameters.\nAssign weights to bias selection on that domain.\nSample from the parameters, given the weights.","category":"page"},{"location":"man/methods/","page":"Testing Methods","title":"Testing Methods","text":"For instance, if a parameter were a string, you wouldn't generate from all random strings. You'd sample first for a string length, with assurance that lengths 0 and 1 are included. Then you'd draw values in the string.","category":"page"},{"location":"man/methods/","page":"Testing Methods","title":"Testing Methods","text":"The test case generation in this library can help bias random testing. For instance, you could assign one partition to edge cases near a=0, one partition to general cases for 0.1 < a < 1000, and one partition to high cases, 1e7 < a < Inf. Let the test case generator say which of the low, mid, or high cases to choose, and then randomly choose values within each test case.","category":"page"},{"location":"man/methods/#Test-selection","page":"Testing Methods","title":"Test selection","text":"","category":"section"},{"location":"man/methods/","page":"Testing Methods","title":"Testing Methods","text":"We can generate a lot of tests. How do we know they are a good set of tests? I'd like to make lots of tests and then keep only those that are sufficiently different from the others that they would find different failures. I don't see any of these tools currently in Julia.","category":"page"},{"location":"man/methods/","page":"Testing Methods","title":"Testing Methods","text":"One measure is line coverage of code. We use all-pairs in order to to generate tests that cover every path through the code. An if-then in the code makes its decision based on variables which, in some way, depend on input parameters. If we include every combination of parameters, we will tend to cover more of the decisions of the if-thens.","category":"page"},{"location":"man/methods/","page":"Testing Methods","title":"Testing Methods","text":"A better measure is mutation analysis. This technique introduces errors into the code, on the fly. Then it runs unit tests against that code in order to ask which unit tests find the same failures. If two unit tests consistently find the same failures, then delete one of them and keep the other.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = UnitTestDesign","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [UnitTestDesign]\nPrivate = false\nOrder = [:type, :function]","category":"page"},{"location":"reference/#UnitTestDesign.Excursion","page":"Reference","title":"UnitTestDesign.Excursion","text":"This class requests tests that are excursions from a base case.\n\n\n\n\n\n","category":"type"},{"location":"reference/#UnitTestDesign.GND","page":"Reference","title":"UnitTestDesign.GND","text":"Greedy Non-deterministic (GND).\n\nThis algorithm searches for test cases. It will generate tuples of any order. It generates a different set every time it is invoked.\n\nArguments\n\nrng::Random.AbstractRNG: This option is a random number generator. Set this if you want to generate the same test cases twice in a row.\nM::Int: The number of times it should create a candidate test case each time it creates a candidate. The default is 50. Raising this number could improve test cases and slow generation.\n\nExtended\n\nThis algorithm starts with the seeded test cases and then adds test cases, one at a time. It chooses those parameters that are least used, so far, and then chooses values of those parameters that are least covered by previous tuples. At each step, there is some probability of choosing among nearly-equal next values.\n\nIt's not complicated, but it can be slow because every next choice checks against all possible tuples. For large numbers of parameters or large numbers of possible values of each parameter, this generator can be slow, so test it for fewer values first and gradually increase the number of parameters or parameter values.\n\n\n\n\n\n","category":"type"},{"location":"reference/#UnitTestDesign.IPOG","page":"Reference","title":"UnitTestDesign.IPOG","text":"In-parameter-order General (IPOG).\n\nThis algorithm generates test cases quickly. It will generate tuples of any order. It always generates the same set of test cases for the same set of input values.\n\nLei, Yu, Raghu Kacker, D. Richard Kuhn, Vadim Okun, and James Lawrence. 2008. “IPOG/IPOG-D: Efficient Test Generation for Multi-Way Combinatorial Testing.” Software Testing, Verification & Reliability 18 (3): 125–48.\n\n\n\n\n\n","category":"type"},{"location":"reference/#UnitTestDesign.all_pairs-Tuple","page":"Reference","title":"UnitTestDesign.all_pairs","text":"all_pairs(parameters...; kwargs...)\n\nEnsure that the returned test cases include every pair of parameters at least once.\n\nExamples\n\nall_pairs([1, 2, 3], [\"a\", \"b\", \"c\"], [true, false])\n\nSee also: all_tuples\n\n\n\n\n\n","category":"method"},{"location":"reference/#UnitTestDesign.all_triples-Tuple","page":"Reference","title":"UnitTestDesign.all_triples","text":"all_triples(parameters...; kwargs...)\n\nEnsure that the returned test cases include every combination of three parameters at least once.\n\nSee also: all_tuples\n\n\n\n\n\n","category":"method"},{"location":"reference/#UnitTestDesign.all_tuples-Tuple","page":"Reference","title":"UnitTestDesign.all_tuples","text":"all_tuples(parameters...; n_way, engine, disallow, seeds, wayness, Counter)\n\nGiven a tuple of parameters, generate all test cases that cover all n_way combinations of those parameters.\n\nArguments\n\nengine=IPOG(): The engine is IPOG(), GND() or Excursion().\ndisallow=nothing: The disallow function is a function of the parameters that returns true when that combination should be forbidden.\nseeds=[]: is a list of test cases that must be included among those\n\ngenerated.\n\nwayness is a dictionary that specifies subsets of parameters for which to increase the n_way combinations. For instance, if the combinations are two-way, and you want the third-sixth parameters to be three-way covered, use, wayness = Dict(3 => [[3, 4, 5, 6]]).\nCounter=IntThe Counter is an integer type to use for\n\nthe computation. It must be large enough to hold the integer number of the parameters.\n\nExamples\n\nall_tuples([1, 2, 3], [\"a\", \"b\", \"c\"], [true, false]; n_way = 2)\nparameters = fill(collect(1:3), 10)\nall_tuples(parameters...; n_way = 4, engine = Excursion())\n\n\n\n\n\n","category":"method"},{"location":"reference/#UnitTestDesign.all_values-Tuple","page":"Reference","title":"UnitTestDesign.all_values","text":"all_values(parameters...; kwargs...)\n\nEnsure that the test cases include every value of every parameter at least once.\n\nSee also: all_tuples\n\n\n\n\n\n","category":"method"},{"location":"reference/#UnitTestDesign.full_factorial-Tuple","page":"Reference","title":"UnitTestDesign.full_factorial","text":"full_factorial(parameters...)\nfull_factorial(parameters...; disallow = filter_function)\n\nGenerates a test case for every combination of the parameters.\n\nExamples\n\nfull_factorial([0.1, 0.2, 0.3], [\"low\", \"high\"], [false, true])\n\nIf you specify a filter function, it will remove combinations that are disallowed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#UnitTestDesign.pairs_excursion-Tuple","page":"Reference","title":"UnitTestDesign.pairs_excursion","text":"pairs_excursion(parameters...; kwargs...)\n\nThis starts with the first choice for each of the parameters. It creates test cases by varying each parameter, one at a time, through its possible values. Then it walks pairs of parameters away from the base case.\n\nExamples\n\npairs_excursion([:a, :b], [1, 2], [1, 2], [\"a\", \"b\"])\n\nSee also: all_tuples\n\n\n\n\n\n","category":"method"},{"location":"reference/#UnitTestDesign.triples_excursion-Tuple","page":"Reference","title":"UnitTestDesign.triples_excursion","text":"pairs_excursion(parameters...; kwargs...)\n\nThis starts with the first choice for each of the parameters. It creates test cases by varying each parameter, one at a time, through its possible values. Then it walks pairs of parameters away from the base case, and finally triples.\n\nSee also: all_tuples\n\n\n\n\n\n","category":"method"},{"location":"reference/#UnitTestDesign.values_excursion-Tuple","page":"Reference","title":"UnitTestDesign.values_excursion","text":"values_excursion(parameters...; kwargs...)\n\nThis starts with the first choice for each of the parameters. It creates test cases by varying each parameter, one at a time, through its possible values.\n\nExamples\n\nvalues_excursion([:a, :b, :c], [1, 2, 3])\n\nSee also: all_tuples\n\n\n\n\n\n","category":"method"},{"location":"man/engines/#Engines","page":"Engines","title":"Engines","text":"","category":"section"},{"location":"man/engines/","page":"Engines","title":"Engines","text":"There are many algorithms to create covering test sets. This library implements two, and you can select which one to use with a keyword argument.","category":"page"},{"location":"man/engines/","page":"Engines","title":"Engines","text":"IPOG: Default The in-parameter-order generator is fast and gives the same result every time.\nGND: This greedy, non-deterministic generator searches for shorter answers and can be slow.\nExcursion: The excursions aren't much of an algorithm. This is a tag to ask the all_tuples function to generate excursions.","category":"page"},{"location":"man/engines/","page":"Engines","title":"Engines","text":"For instance, this example has ten parameters which can each take one of four values.","category":"page"},{"location":"man/engines/","page":"Engines","title":"Engines","text":"using Random  # hide\nusing UnitTestDesign # hide\nparameters = fill(collect(1:4), 10)\nfast_and_longer = all_pairs(parameters...; engine = IPOG())","category":"page"},{"location":"man/engines/","page":"Engines","title":"Engines","text":"rng = Random.MersenneTwister(9790242)\nslow_and_short = all_pairs(parameters...; engine = GND(rng = rng, M = 50))","category":"page"},{"location":"#UnitTestDesign","page":"Home","title":"UnitTestDesign","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package to generate parameters for unit tests and test data for unit tests. You tell it possible values for each parameter of a function, and it selects combinations of parameters that are most likely to find problems in that function.","category":"page"},{"location":"","page":"Home","title":"Home","text":"All-pairs, all-triples, and higher-order coverage of test cases.\nCombinatorial excursions from a base test case.\nConvenient ways to avoid uninteresting parameter combinations, add necessary test cases, and increase coverage for subsets of parameters.","category":"page"},{"location":"#Install","page":"Home","title":"Install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/adolgert/UnitTestDesign.jl","category":"page"},{"location":"#Description","page":"Home","title":"Description","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Write a unit test using the all_pairs function.","category":"page"},{"location":"","page":"Home","title":"Home","text":"test_set = all_pairs(\n    [1, 2, 3], [\"low\", \"mid\" ,\"high\"], [1.0, 3.7, 4.9], [:greedy, :relax, :optim]\n    )\nfor test_case in test_set\n    test_result = function_under_test(test_case...)\n    @test test_result == known_result(test_case)\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package doesn't help write the code that knows what the correct test result should be.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In order to test every possible input to the function above, you would need 81 tests, but this generates 10 tests that are more likely to find most faults because they include every combination of each pair of parameter values.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using UnitTestDesign\ntest_cases = all_pairs(\n    [1, 2, 3], [\"low\", \"mid\" ,\"high\"], [1.0, 3.7, 4.9], [:greedy, :relax, :optim])","category":"page"},{"location":"man/examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"man/examples/#Test-parameter-generation","page":"Examples","title":"Test parameter generation","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"For a small test set, generate tests is quick.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"test_set = all_pairs(\n    [(-3, -2),  (2, 3), (-2, 3), (4.999, 5), (0, 1e7)],\n    [0.1, 0.01, 0.001],\n    [:RungeKutta, :Midpoint]\n    )\nfor test_case in test_set\n    a, b = test_case[1]\n    result = custom_integrate(a, b, test_case[2:end]...)\n    @test result == compare_with_symbolic_integration(a, b)\nend","category":"page"},{"location":"man/examples/#Save-larger-test-suites-instead-of-regenerating","page":"Examples","title":"Save larger test suites instead of regenerating","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"For a larger test set, it can be worthwhile to make test suites and save them.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"wide_test = all_triples(fill(1:4, 30)...)\nJLD.save(\"test_artifact.jld\", \"wide_test\", wide_test)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"These could then be made available for testing through Pkg.Artifacts.","category":"page"},{"location":"man/examples/#Test-data-generation","page":"Examples","title":"Test data generation","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"We use combinatoric testing because it finds all code paths. Code paths are lines of code chosen by the same if-then decision. Some code has few code paths but many branches. For instance, data_frame = all_data_frame[data_frame[:, :time] > 10] has two branches, one for times less than ten and one for times greater than ten.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"This library will create test data as easily as it creates test cases.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"using UnitTestDesign  # hide\nusing DataFrames\nnames = [\"time\", \"event\", \"who\", \"location\"]\nat = all_triples([0.1, 5.1, 10.9], [:infect, :recover], [10, 11], [\"forest\", \"home\"])\nDataFrame(Dict(names[i] => [row[i] for row in at] for i in 1:length(names))...)","category":"page"},{"location":"man/examples/#Excursions","page":"Examples","title":"Excursions","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"If you want to start with a single test that you know is a common way to call a function, then an excursion can generate variations around that common way. It picks one parameter and walks through its values. Then another. If you choose a pair-wise excursion, it walks all pairs away from the initial value.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"using UnitTestDesign  # hide\nvalues_excursion([1, 2], [true, false], [\"c\", \"b\", \"a\"])","category":"page"},{"location":"man/examples/#Filtering-a-factorial","page":"Examples","title":"Filtering a factorial","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The full-factorial test generates every possible test. If some combinations of parameters aren't interesting or allowed for a function, you can exclude them by using an extra argument.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"using UnitTestDesign  # hide\ndisallow = (a, b, c) -> b == 7 && c == false\nfull_factorial([1, 2, 3], [7, 8], [true, false]; disallow = disallow)","category":"page"},{"location":"man/greedy/#Greedy-Fractional-Factorial-Parameter-Generators","page":"Greedy Fractional Factorial Parameter Generators","title":"Greedy Fractional Factorial Parameter Generators","text":"","category":"section"},{"location":"man/greedy/","page":"Greedy Fractional Factorial Parameter Generators","title":"Greedy Fractional Factorial Parameter Generators","text":"This creates a fractional factorial test design for the parameters. Out of all possible combinations of parameters, this chooses a subset that contains every possible pair of inputs, or every possible triple, or even every possible value of each parameter.","category":"page"},{"location":"man/greedy/","page":"Greedy Fractional Factorial Parameter Generators","title":"Greedy Fractional Factorial Parameter Generators","text":"The method constructs a list of every tuple that must be tested. Then it uses weighted random number generation to construct a complete set of parameters that includes as many of those tuples as possible.","category":"page"}]
}
