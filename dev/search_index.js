var documenterSearchIndex = {"docs":
[{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/#Examples-of-contributions","page":"Contributing","title":"Examples of contributions","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Adding an algorithm for test case generation.\nTelling me which package already has an algorithm to use.\nImproving the documentation or testing builds.\nSuggesting a better API.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"The Github site has an Issues page, and my email is listed.","category":"page"},{"location":"contributing/#Branch-process","page":"Contributing","title":"Branch process","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"The main branch is for development.\nReleases go to release.","category":"page"},{"location":"contributing/#Conduct","page":"Contributing","title":"Conduct","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Let's follow the contributor covenant.","category":"page"},{"location":"man/guide/#Guide","page":"Guide","title":"Guide","text":"","category":"section"},{"location":"man/guide/#Kinds-of-test-generation","page":"Guide","title":"Kinds of test generation","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Combinatorial coverage - Makes the shortest test sets to cover all options.\nall_values: Every value is used at least once.\nall_pairs: Every pair of values is used at least once.\nall_triples: Every triple of values is used at least once.\nall_tuples: Generate test sets with arbitrary coverage level.\nExcursions from a single parameter set\nvalues_excursion: Tries each parameter, one at a time.\npairs_excursion: Tries pairs of parameters, two at a time.\ntriples_excursion: Tries three parameters away from the original set.\nall_tuples: This function works for general excursions, too.\nFull factorial - Every combinations of parameters.\nfull_factorial: Generates all combinations of parameters, filtering those that aren't permitted.","category":"page"},{"location":"man/guide/#Same-interface-for-all-of-test-generators","page":"Guide","title":"Same interface for all of test generators","text":"","category":"section"},{"location":"man/guide/#Increase-coverage-for-subsets-of-parameters","page":"Guide","title":"Increase coverage for subsets of parameters","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Sometimes there are a few parameters that are more important to test fully. In that case, choose a base-level coverage for the whole test set, such as the 2-way coverage of all-pairs. Then pass a separate argument to request that the subset of parameters have greater coverage.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"For instance, this requrests that the first, third, and fourth parameters have 3-way coverage, meaning full-factorial, while the second parameter has only 2-way coverage. This is more meaningful when there are lots of parameters.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"test_set = all_pairs(\n    [1, 2, 3], [\"low\", \"mid\" ,\"high\"], [1.0, 3.7, 4.9], [:greedy, :relax, :optim];\n    wayness = Dict(3 => [[1, 3, 4]])\n    )","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The wayness argument is a dictionary, where the dictionary keys are the higher coverage levels, so \"3\" means all triples. The dictionary values are an array of arrays of parameter indices which, together, should be covered at the given level. This means that, were you to have 40 parameters, you could request that parameters [3:6] and parameters [25:30] be covered with triples.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"test_set = all_pairs(\n    array_of_forty_parameters...;\n    wayness = Dict(3 => [[3:6], [25:30]])\n    )","category":"page"},{"location":"man/guide/#Exclude-forbidden-combinations-of-parameters","page":"Guide","title":"Exclude forbidden combinations of parameters","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Keep the test engine from making tests that aren't allowed for your function. Pass it a filter function, one that returns true whenever a parameter combinations is forbidden.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"disallow(n, level, value, kind) = level == \"high\" && kind == :optim\ntest_set = all_pairs(\n    [1, 2, 3], [\"low\", \"mid\" ,\"high\"], [1.0, 3.7, 4.9], [:greedy, :relax, :optim];\n    filter = disallow\n    )","category":"page"},{"location":"man/guide/#Seed-test-cases","page":"Guide","title":"Seed test cases","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"If there are particular tests that must be run, these already include some of the tuples that should be covered. You can pass the must-run test cases, and they will be included among the test cases.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"must_test = [[1, \"mid\", 3.7, :relax], [1, \"mid\", 4.9, :relax]]\ntest_cases = all_pairs(\n    [1, 2, 3], [\"low\", \"mid\" ,\"high\"], [1.0, 3.7, 4.9], [:greedy, :relax, :optim];\n    seeds = must_test\n    )","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The must-run cases are a list of arrays of arguments.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = UnitTestDesign","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [UnitTestDesign]\nPrivate = false\nOrder = [:type, :function]","category":"page"},{"location":"reference/#UnitTestDesign.Excursion","page":"Reference","title":"UnitTestDesign.Excursion","text":"This class requests tests that are excursions from a base case.\n\n\n\n\n\n","category":"type"},{"location":"reference/#UnitTestDesign.GND","page":"Reference","title":"UnitTestDesign.GND","text":"Greedy Non-deterministic (GND).\n\nThis algorithm searches for test cases. It will generate tuples of any order. It generates a different set every time it is invoked.\n\nArguments\n\nrng::Random.AbstractRNG: This option is a random number generator. Set this if you want to generate the same test cases twice in a row.\nM::Int: The number of times it should create a candidate test case each time it creates a candidate. The default is 50. Raising this number could improve test cases and slow generation.\n\nExtended\n\nThis algorithm starts with the seeded test cases and then adds test cases, one at a time. It chooses those parameters that are least used, so far, and then chooses values of those parameters that are least covered by previous tuples. At each step, there is some probability of choosing among nearly-equal next values.\n\nIt's not complicated, but it can be slow because every next choice checks against all possible tuples. For large numbers of parameters or large numbers of possible values of each parameter, this generator can be slow, so test it for fewer values first and gradually increase the number of parameters or parameter values.\n\n\n\n\n\n","category":"type"},{"location":"reference/#UnitTestDesign.IPOG","page":"Reference","title":"UnitTestDesign.IPOG","text":"In-parameter-order General (IPOG).\n\nThis algorithm generates test cases quickly. It will generate tuples of any order. It always generates the same set of test cases for the same set of input values.\n\nLei, Yu, Raghu Kacker, D. Richard Kuhn, Vadim Okun, and James Lawrence. 2008. “IPOG/IPOG-D: Efficient Test Generation for Multi-Way Combinatorial Testing.” Software Testing, Verification & Reliability 18 (3): 125–48.\n\n\n\n\n\n","category":"type"},{"location":"reference/#UnitTestDesign.all_pairs-Tuple","page":"Reference","title":"UnitTestDesign.all_pairs","text":"all_pairs(parameters...; kwargs...)\n\nEnsure that the returned test cases include every pair of parameters at least once.\n\nExamples\n\nall_pairs([1, 2, 3], [\"a\", \"b\", \"c\"], [true, false])\n\nSee also: all_tuples\n\n\n\n\n\n","category":"method"},{"location":"reference/#UnitTestDesign.all_triples-Tuple","page":"Reference","title":"UnitTestDesign.all_triples","text":"all_triples(parameters...; kwargs...)\n\nEnsure that the returned test cases include every combination of three parameters at least once.\n\nSee also: all_tuples\n\n\n\n\n\n","category":"method"},{"location":"reference/#UnitTestDesign.all_tuples-Tuple","page":"Reference","title":"UnitTestDesign.all_tuples","text":"all_tuples(parameters...; n_way, engine, disallow, seeds, wayness, Counter)\n\nGiven a tuple of parameters, generate all test cases that cover all n_way combinations of those parameters.\n\nArguments\n\nengine=IPOG(): The engine is IPOG(), GND() or Excursion().\ndisallow=nothing: The disallow function is a function of the parameters that returns true when that combination should be forbidden.\nseeds=[]: is a list of test cases that must be included among those\n\ngenerated.\n\nwayness is a dictionary that specifies subsets of parameters for which to increase the n_way combinations. For instance, if the combinations are two-way, and you want the third-sixth parameters to be three-way covered, use, wayness = Dict(3 => [[3, 4, 5, 6]]).\nCounter=IntThe Counter is an integer type to use for\n\nthe computation. It must be large enough to hold the integer number of the parameters.\n\nExamples\n\nall_tuples([1, 2, 3], [\"a\", \"b\", \"c\"], [true, false]; n_way = 2)\nparameters = fill(collect(1:3), 10)\nall_tuples(parameters...; n_way = 4, engine = Excursion())\n\n\n\n\n\n","category":"method"},{"location":"reference/#UnitTestDesign.all_values-Tuple","page":"Reference","title":"UnitTestDesign.all_values","text":"all_values(parameters...; kwargs...)\n\nEnsure that the test cases include every value of every parameter at least once.\n\nSee also: all_tuples\n\n\n\n\n\n","category":"method"},{"location":"reference/#UnitTestDesign.full_factorial-Tuple","page":"Reference","title":"UnitTestDesign.full_factorial","text":"full_factorial(parameters...)\nfull_factorial(parameters...; disallow = filter_function)\n\nGenerates a test case for every combination of the parameters.\n\nExamples\n\nfull_factorial([0.1, 0.2, 0.3], [\"low\", \"high\"], [false, true])\n\nIf you specify a filter function, it will remove combinations that are disallowed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#UnitTestDesign.pairs_excursion-Tuple","page":"Reference","title":"UnitTestDesign.pairs_excursion","text":"pairs_excursion(parameters...; kwargs...)\n\nThis starts with the first choice for each of the parameters. It creates test cases by varying each parameter, one at a time, through its possible values. Then it walks pairs of parameters away from the base case.\n\nExamples\n\npairs_excursion([:a, :b], [1, 2], [1, 2], [\"a\", \"b\"])\n\nSee also: all_tuples\n\n\n\n\n\n","category":"method"},{"location":"reference/#UnitTestDesign.triples_excursion-Tuple","page":"Reference","title":"UnitTestDesign.triples_excursion","text":"pairs_excursion(parameters...; kwargs...)\n\nThis starts with the first choice for each of the parameters. It creates test cases by varying each parameter, one at a time, through its possible values. Then it walks pairs of parameters away from the base case, and finally triples.\n\nSee also: all_tuples\n\n\n\n\n\n","category":"method"},{"location":"reference/#UnitTestDesign.values_excursion-Tuple","page":"Reference","title":"UnitTestDesign.values_excursion","text":"values_excursion(parameters...; kwargs...)\n\nThis starts with the first choice for each of the parameters. It creates test cases by varying each parameter, one at a time, through its possible values.\n\nExamples\n\nvalues_excursion([:a, :b, :c], [1, 2, 3])\n\nSee also: all_tuples\n\n\n\n\n\n","category":"method"},{"location":"man/engines/#Engines","page":"Engines","title":"Engines","text":"","category":"section"},{"location":"man/engines/","page":"Engines","title":"Engines","text":"There are many algorithms to create covering test sets. This library implements two, and you can select which one to use with a keyword argument.","category":"page"},{"location":"man/engines/","page":"Engines","title":"Engines","text":"IPOG: Default The in-parameter-order generator is fast and gives the same result every time.\nGND: This greedy, non-deterministic generator searches for shorter answers and can be slow.\nExcursion: The excursions aren't much of an algorithm. This is a tag to ask the all_tuples function to generate excursions.","category":"page"},{"location":"man/engines/","page":"Engines","title":"Engines","text":"For instance, this example has ten parameters which can each take one of four values.","category":"page"},{"location":"man/engines/","page":"Engines","title":"Engines","text":"using Random  # hide\nusing UnitTestDesign # hide\nparameters = fill(collect(1:4), 10)\nfast_and_longer = all_pairs(parameters...; engine = IPOG())","category":"page"},{"location":"man/engines/","page":"Engines","title":"Engines","text":"rng = Random.MersenneTwister(9790242)\nslow_and_short = all_pairs(parameters...; engine = GND(rng = rng, M = 50))","category":"page"},{"location":"#UnitTestDesign","page":"Home","title":"UnitTestDesign","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package to generate test cases for unit tests. This provides all-pairs and higher-order algorithms.","category":"page"},{"location":"","page":"Home","title":"Home","text":"All-pairs, all-triples, and higher-order coverage of test cases.\nCombinatorial excursions from a base test case.\nConvenient ways to avoid uninteresting parameter combinations, add necessary test cases, and increase coverage for subsets of parameters.","category":"page"},{"location":"#Install","page":"Home","title":"Install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/adolgert/UnitTestDesign.jl","category":"page"},{"location":"#Description","page":"Home","title":"Description","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If we have a function-under-test that takes four arguments, each of which can have three possible values, then there are 81 possible combinations of inputs. The all_pairs function selects 10 inputs that contain every pair parameter values at least once.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using UnitTestDesign\ntest_cases = all_pairs(\n    [1, 2, 3], [\"low\", \"mid\" ,\"high\"], [1.0, 3.7, 4.9], [:greedy, :relax, :optim])","category":"page"},{"location":"","page":"Home","title":"Home","text":"Each item in this array is a set of parameters for unit testing the function. This test set is an example of all-pairs because we can pick any two parameters (second and fourth), pick any of the values for those parameters (\"mid\" and :relax), and find them in one of the test cases (the 2nd one).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Use a test set for unit testing:","category":"page"},{"location":"","page":"Home","title":"Home","text":"test_set = all_pairs(\n    [1, 2, 3], [\"low\", \"mid\" ,\"high\"], [1.0, 3.7, 4.9], [:greedy, :relax, :optim]\n    )\nfor test_case in test_set\n    test_result = function_under_test(test_case...)\n    @test test_result == known_result(test_case)\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package doesn't help write the code that knows what the correct test result should be.","category":"page"},{"location":"man/greedy/#Greedy-Fractional-Factorial-Parameter-Generators","page":"Greedy Fractional Factorial Parameter Generators","title":"Greedy Fractional Factorial Parameter Generators","text":"","category":"section"},{"location":"man/greedy/","page":"Greedy Fractional Factorial Parameter Generators","title":"Greedy Fractional Factorial Parameter Generators","text":"This creates a fractional factorial test design for the parameters. Out of all possible combinations of parameters, this chooses a subset that contains every possible pair of inputs, or every possible triple, or even every possible value of each parameter.","category":"page"},{"location":"man/greedy/","page":"Greedy Fractional Factorial Parameter Generators","title":"Greedy Fractional Factorial Parameter Generators","text":"The method constructs a list of every tuple that must be tested. Then it uses weighted random number generation to construct a complete set of parameters that includes as many of those tuples as possible.","category":"page"},{"location":"man/usage/#Usage-in-context","page":"Usage","title":"Usage in context","text":"","category":"section"},{"location":"man/usage/#Test-generation","page":"Usage","title":"Test generation","text":"","category":"section"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"We use test case generation tools, like this library, when tests take too long to run. It can be worthwhile to generate smaller test suites by running slower test case generators (such as GND). The development process is:","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"Generate test cases.\nSave test cases to a file, a testing artifact, or copied to the unit test as data.\nLoad the test cases for unit testing.","category":"page"},{"location":"man/usage/#Test-data-generation","page":"Usage","title":"Test data generation","text":"","category":"section"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"We use combinatoric testing because it finds all code paths. Code paths are lines of code chosen by the same if-then decision. Some code has few code paths but many branches. For instance, data_frame = all_data_frame[data_frame[:, :time] > 10] has two branches, one for times less than ten and one for times greater than ten.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"This library will create test data as easily as it creates test cases.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"using DataFrames\nnames = [\"time\", \"event\", \"who\", \"location\"]\nat = all_triples([0.1, 5.1, 10.9], [:infect, :recover], [10, 11, 12], [\"forest\", \"home\"])\nDataFrame(Dict(names[i] => [row[i] for row in at] for i in 1:length(names))...)","category":"page"},{"location":"man/usage/#Partition-testing","page":"Usage","title":"Partition testing","text":"","category":"section"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"We've pretended, so far, that every function takes parameters that are selected from discrete, finite choices. Functions arguments can be floating-point values, integers from infinite sets, vectors of values, or trees of trees of values. Partition testing whittles down the nearly-infinite possible values into subsets which are likely to find the same faults in the function-under-test.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"If a function integrates a value from a to b, then we could partition the possible a and b test values into those that are both negative, both positive, one negative and one positive. We could make a separate case for when they are very nearly equal or equal. That would make five partitions for these two variables. For each of those five partitions, we guess that it would be enough to choose some example value for testing.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"test_set = all_pairs(\n    [:neg, :pos, :split, :near, :far], [0.1, 0.01, 0.001], [:RungeKutta, :Midpoint]\n    )\nab = Dict(:neg => (-3, -2), :pos => (2, 3), :split => (-2, 3),\n    :near => (4.999, 5), :far => (0, 1e7)\n)\nfor test_case in test_set\n    a, b = ab[test_case[1]]\n    result = custom_integrate(a, b, test_case[2:end]...)\n    @test result == compare_with_symbolic_integration(a, b)\nend","category":"page"},{"location":"man/usage/#Random-testing","page":"Usage","title":"Random testing","text":"","category":"section"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"Random testing side-steps the work, and fallibility, of partition testing by choosing input values randomly from their domain. If a can be any number between 0 and infinity, then let a random number generator pick it.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"Random testing isn't blind to understanding what can go wrong in a function. It's no reason to forget to test edge cases. There is a procedure for constructing random tests that are biased towards finding edge cases.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"Identify the whole domain of each parameter and the set of parameters.\nAssign weights to bias selection on that domain.\nSample from the parameters, given the weights.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"For instance, if a parameter were a string, you wouldn't generate from all random strings. You'd sample first for a string length, with assurance that lengths 0 and 1 are included. Then you'd draw values in the string.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"The test case generation in this library can help bias random testing. For instance, you could assign one partition to edge cases near a=0, one partition to general cases for 0.1 < a < 1000, and one partition to high cases, 1e7 < a < Inf. Let the test case generator say which of the low, mid, or high cases to choose, and then randomly choose values within each test case.","category":"page"},{"location":"man/usage/#Test-selection","page":"Usage","title":"Test selection","text":"","category":"section"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"We can generate a lot of tests. How do we know they are a good set of tests? I'd like to make lots of tests and then keep only those that are sufficiently different from the others that they would find different failures. I don't see any of these tools currently in Julia.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"One measure is line coverage of code. We use all-pairs in order to to generate tests that cover every path through the code. An if-then in the code makes its decision based on variables which, in some way, depend on input parameters. If we include every combination of parameters, we will tend to cover more of the decisions of the if-thens.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"A better measure is mutation analysis. This technique introduces errors into the code, on the fly. Then it runs unit tests against that code in order to ask which unit tests find the same failures. If two unit tests consistently find the same failures, then delete one of them and keep the other.","category":"page"}]
}
