<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Testing Methods · UnitTestDesign.jl</title><link rel="canonical" href="https://adolgert.github.io/UnitTestDesign.jl/man/methods/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">UnitTestDesign.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../guide/">Guide</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>Testing Methods</a><ul class="internal"><li><a class="tocitem" href="#Partition-testing"><span>Partition testing</span></a></li><li><a class="tocitem" href="#Random-testing"><span>Random testing</span></a></li><li><a class="tocitem" href="#Test-selection"><span>Test selection</span></a></li></ul></li><li><a class="tocitem" href="../engines/">Engines</a></li><li><a class="tocitem" href="../ipog/">IPOG</a></li></ul></li><li><a class="tocitem" href="../../reference/">Reference</a></li><li><a class="tocitem" href="../../contributing/">Contributing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Testing Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Testing Methods</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/adolgert/UnitTestDesign.jl/blob/master/docs/src/man/methods.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Testing-Methods"><a class="docs-heading-anchor" href="#Testing-Methods">Testing Methods</a><a id="Testing-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Testing-Methods" title="Permalink"></a></h1><h2 id="Partition-testing"><a class="docs-heading-anchor" href="#Partition-testing">Partition testing</a><a id="Partition-testing-1"></a><a class="docs-heading-anchor-permalink" href="#Partition-testing" title="Permalink"></a></h2><p>We&#39;ve pretended, so far, that every function takes parameters that are selected from discrete, finite choices. Functions arguments can be floating-point values, integers from infinite sets, vectors of values, or trees of trees of values. <em>Partition testing</em> whittles down the nearly-infinite possible values into subsets which are likely to find the same faults in the function-under-test.</p><p>If a function integrates a value from <code>a</code> to <code>b</code>, then we could partition the possible <code>a</code> and <code>b</code> test values into those that are both negative, both positive, one negative and one positive. We could make a separate case for when they are very nearly equal or equal. That would make five partitions for these two variables. For each of those five partitions, we guess that it would be enough to choose some example value for testing.</p><pre><code class="language-julia">test_set = all_pairs(
    [:neg, :pos, :split, :near, :far], [0.1, 0.01, 0.001], [:RungeKutta, :Midpoint]
    )
ab = Dict(:neg =&gt; (-3, -2), :pos =&gt; (2, 3), :split =&gt; (-2, 3),
    :near =&gt; (4.999, 5), :far =&gt; (0, 1e7)
)
for test_case in test_set
    a, b = ab[test_case[1]]
    result = custom_integrate(a, b, test_case[2:end]...)
    @test result == compare_with_symbolic_integration(a, b)
end</code></pre><h2 id="Random-testing"><a class="docs-heading-anchor" href="#Random-testing">Random testing</a><a id="Random-testing-1"></a><a class="docs-heading-anchor-permalink" href="#Random-testing" title="Permalink"></a></h2><p>Random testing side-steps the work, and fallibility, of partition testing by choosing input values randomly from their domain. If <code>a</code> can be any number between 0 and infinity, then let a random number generator pick it.</p><p>Random testing isn&#39;t blind to understanding what can go wrong in a function. It&#39;s no reason to forget to test edge cases. There is a procedure for constructing random tests that are biased towards finding edge cases.</p><ol><li>Identify the whole domain of each parameter and the set of parameters.</li><li>Assign weights to bias selection on that domain.</li><li>Sample from the parameters, given the weights.</li></ol><p>For instance, if a parameter were a string, you wouldn&#39;t generate from all random strings. You&#39;d sample first for a string length, with assurance that lengths 0 and 1 are included. Then you&#39;d draw values in the string.</p><p>The test case generation in this library can help bias random testing. For instance, you could assign one partition to edge cases near <code>a=0</code>, one partition to general cases for <code>0.1 &lt; a &lt; 1000</code>, and one partition to high cases, <code>1e7 &lt; a &lt; Inf</code>. Let the test case generator say which of the low, mid, or high cases to choose, and then randomly choose values within each test case.</p><h2 id="Test-selection"><a class="docs-heading-anchor" href="#Test-selection">Test selection</a><a id="Test-selection-1"></a><a class="docs-heading-anchor-permalink" href="#Test-selection" title="Permalink"></a></h2><p>We can generate a lot of tests. How do we know they are a good set of tests? I&#39;d like to make lots of tests and then keep only those that are sufficiently different from the others that they would find different failures. There is opportunity for test selection tools in the Julia testing ecosystem, so let&#39;s make a recipe for how test selection would work, in three steps.</p><ol><li><p>Every test, manual or generated, needs to be recorded by the test framework so that the framework can observe the test run and select it to include in the test suite.</p></li><li><p>There has to be a way to measure each of those tests, as criteria for inclusion in the production test suite. These can be measurements of resource usage, such as runtime or memory requirements, but they can also be code coverage of the individual tests.</p></li><li><p>Finally, the test selection framework will use those criteria to prioritize or exclude tests from later test runs. This can be used to reduce the size of a test suite or it can be used to choose the tests that have most often failed in the past and run them first.</p></li></ol><p>All three of these steps are challenging. For the first step, the Julia framework considers the <code>@testset</code> the smallest unit of testing, so a test automation tool would need to generate many <code>@testset</code> instances. While the main framework won&#39;t record and replay tests, optional frameworks such as <a href="https://github.com/fjarri/Jute.jl">Jute.jl</a> can.</p><p>For the second step, it can be difficult to record coverage of individual tests. The classic measure is line coverage, and, while Julia has built-in ways to measure coverage for invocation of whole applications, the same facility isn&#39;t available for testing coverage of individual tests.</p><p>The other challenge of coverage is that line coverage isn&#39;t a strong indicator of how thorough testing is. Correlation between coverage and fault-finding diminishes above sixty percent coverage. There is an alternative kind of coverage, called mutation coverage, that has better support as an indicator of testing thoroughness. This technique introduces errors, mutations, into the code on the fly. Then it runs unit tests against that code in order to ask which unit tests find the error. This is a different technique from mutation testing (<a href="https://github.com/MikeInnes/Vimes.jl">Vimes.jl</a>), but it uses the same tools. The trouble with mutation coverage is that it&#39;s very slow. There aren&#39;t known methods for calculating mutation coverage and then updating it incrementally when there is a change to the code.</p><p>The last step is test selection. We run tests at different times for different reasons, and there are different tests we might like to select. For instance, we would run all of the tests during acceptance testing. For continuous integration on Github, maybe it&#39;s better to run less resource-intensive tests in order to save computing time. For checkout testing, when you first install software on your local computer, you might choose to run tests that will interact more closely with architecture-specific machine instructions. And a most common choice is to select first for testing those that failed most recently, because that&#39;s the bug you were fixing. So a good test selection tool would be situation-specific.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Examples</a><a class="docs-footer-nextpage" href="../engines/">Engines »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 6 November 2021 18:04">Saturday 6 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
